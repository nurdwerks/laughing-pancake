<!DOCTYPE html>
<html>
<head>
    <title>Rust Chess AI</title>
    <link rel="stylesheet" href="main_style.css">
</head>
<body>
    <div class="main-container">
        <div id="status-bar">
            <div id="generation-status" class="status-gauge"></div>
            <div id="cpu-status" class="status-gauge"></div>
            <div id="mem-status" class="status-gauge"></div>
        </div>

        <div id="matches-container">
            <!-- Match panes will be dynamically inserted here -->
        </div>

        <div id="bottom-container">
            <div id="log-container" style="flex: 2;">
                <h2>Log</h2>
                <div id="log-content" class="scroll-content"></div>
            </div>
            <div id="workers-container" style="flex: 1;">
                <h2>Running Threads</h2>
                <div id="workers-content" class="scroll-content"></div>
            </div>
            <div id="system-stats-container" style="flex: 1;">
                 <!-- System stats will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <div id="buttons">
        <a href="history.html" class="button-link">View History</a>
        <a href="sts.html" class="button-link">STS Dashboard</a>
        <button id="force_quit">Force Quit</button>
        <button id="reset_simulation">Reset Simulation</button>
    </div>

    <script>
        const PIECE_SYMBOLS = {
            'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚',
            'P': '♟', 'R': '♜', 'N': '♞', 'B': '♝', 'Q': '♛', 'K': '♚'
        };

        let ws;
        let gitHash = null;

        function connect() {
            console.log("Attempting to connect to WebSocket...");
            ws = new WebSocket(`${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws`);

            ws.onopen = () => {
                console.log("WebSocket connection established.");
                ws.send(JSON.stringify({ subscribe: "State" }));
                ws.send(JSON.stringify({ subscribe: "Log" }));
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);

                if (msg.type === 'State') {
                    const state = msg.payload;
                    if (gitHash === null) {
                        gitHash = state.git_hash;
                    } else if (gitHash !== state.git_hash) {
                        console.log("Git hash changed, reloading page.");
                        window.location.reload();
                    }
                    updateUi(state);
                } else if (msg.type === 'Log') {
                    appendLog(msg.payload);
                }
            };

            ws.onclose = () => {
                console.log("WebSocket connection closed. Attempting to reconnect in 1 second...");
                // Attempt to reconnect after a delay
                setTimeout(connect, 1000);
            };

            ws.onerror = (err) => {
                console.error("WebSocket error:", err);
                ws.close();
            };

            document.getElementById('force_quit').onclick = () => ws.send('force_quit');
            document.getElementById('reset_simulation').onclick = () => {
                if (confirm('Are you sure you want to reset the simulation? This will delete all progress.')) {
                    ws.send('reset_simulation');
                }
            };
        }

        connect();

        function updateStatusBar(state) {
            // Generation Status
            const genDiv = document.getElementById('generation-status');
            if (state.graceful_shutdown) {
                genDiv.innerHTML = 'Graceful shutdown initiated. Waiting for matches to complete...';
            } else {
                const progress = state.evolution_total_matches > 0 ? (state.evolution_matches_completed / state.evolution_total_matches) : 0;
                const round_text = state.evolution_total_rounds > 0 ? `R: ${state.evolution_current_round}/${state.evolution_total_rounds}` : '';
                genDiv.innerHTML = `
                    <div>G: ${state.evolution_current_generation} | ${round_text} | M: ${state.evolution_matches_completed}/${state.evolution_total_matches}</div>
                    <progress value="${progress}" max="1"></progress>
                `;
            }

            // CPU Status
            const cpuDiv = document.getElementById('cpu-status');
            cpuDiv.innerHTML = `
                <div>CPU Usage</div>
                <progress value="${state.cpu_usage}" max="100"></progress>
                <span>${state.cpu_usage.toFixed(2)}%</span>
            `;

            // Memory Status
            const memDiv = document.getElementById('mem-status');
            const memUsedGb = state.memory_usage / (1024 * 1024 * 1024);
            const memTotalGb = state.total_memory / (1024 * 1024 * 1024);
            memDiv.innerHTML = `
                <div>Memory Usage</div>
                <progress value="${state.memory_usage}" max="${state.total_memory}"></progress>
                <span>${memUsedGb.toFixed(2)} / ${memTotalGb.toFixed(2)} GB</span>
            `;
        }

        function updateMatches(matches) {
            const container = document.getElementById('matches-container');
            container.innerHTML = ''; // Clear existing matches

            const sortedMatches = Object.entries(matches).sort(([idA], [idB]) => idA - idB);

            if (sortedMatches.length === 0) {
                container.innerHTML = '<div style="text-align: center; width: 100%;">Waiting for matches to start...</div>';
                return;
            }

            for (const [id, match] of sortedMatches) {
                const pane = document.createElement('div');
                pane.className = 'match-pane';

                const header = document.createElement('div');
                header.className = 'match-header';
                const white_name = match.white_player.split('.')[0];
                const black_name = match.black_player.split('.')[0];
                const white_num = white_name.split('_').pop();
                const black_num = black_name.split('_').pop();
                header.textContent = `M${id}: ${white_num} v ${black_num}`;

                const boardContainer = document.createElement('div');
                boardContainer.className = 'board-container';
                boardContainer.innerHTML = renderBoard(match.board);

                const sanContainer = document.createElement('div');
                sanContainer.className = 'san-container';
                sanContainer.innerHTML = `<strong>Eval:</strong> ${match.eval} | <strong>Material:</strong> ${match.material}<br>${match.san}`;

                pane.appendChild(header);
                pane.appendChild(boardContainer);
                pane.appendChild(sanContainer);
                container.appendChild(pane);
            }
        }

        function renderBoard(fen) {
            const [boardState] = fen.split(' ');
            const rows = boardState.split('/');
            let html = '<div class="board">';

            for (let i = 0; i < 8; i++) {
                const row = rows[i];
                for (let j = 0; j < 8; j++) {
                    const isDark = (i + j) % 2 !== 0;
                    html += `<div class="square ${isDark ? 'dark' : 'light'}">`;

                    const piece = getPieceAt(row, j);
                    if (piece) {
                        const colorClass = piece === piece.toUpperCase() ? 'white-piece' : 'black-piece';
                        html += `<span class="piece ${colorClass}">${PIECE_SYMBOLS[piece]}</span>`;
                    } else {
                        html += '&nbsp;';
                    }
                    html += '</div>';
                }
            }
            html += '</div>';
            return html;
        }

        // This is a helper because FEN is tricky with the numbers for empty squares
        function getPieceAt(fenRow, fileIndex) {
            let currentFile = 0;
            for (const char of fenRow) {
                if (isNaN(parseInt(char))) { // It's a piece
                    if (currentFile === fileIndex) {
                        return char;
                    }
                    currentFile++;
                } else { // It's a number for empty squares
                    const emptySquares = parseInt(char);
                    if (fileIndex >= currentFile && fileIndex < currentFile + emptySquares) {
                        return null;
                    }
                    currentFile += emptySquares;
                }
            }
            return null; // Should not be reached in a valid FEN
        }


        function updateUi(state) {
            updateStatusBar(state);
            updateSystemStats(state);
            updateMatches(state.active_matches);
            updateWorkers(state.evolution_workers);
        }

        function appendLog(message) {
            const container = document.getElementById('log-content');
            const atBottom = container.scrollHeight - container.clientHeight <= container.scrollTop + 1;

            const line = document.createElement('div');
            line.innerHTML = message;
            container.appendChild(line);

            // Keep the log to a max of 100 entries
            while (container.children.length > 100) {
                container.removeChild(container.firstChild);
            }

            if (atBottom) {
                container.scrollTop = container.scrollHeight;
            }
        }

        function updateWorkers(workers) {
            const container = document.getElementById('workers-content');
            if (workers.length === 0) {
                container.innerHTML = 'Waiting for AI move...';
                return;
            }
            container.innerHTML = workers
                .sort((a, b) => b.elapsed_time - a.elapsed_time)
                .map(w => `<div>${w.elapsed_time.toFixed(2)}s: ${w.name}</div>`)
                .join('');
        }

        function updateSystemStats(state) {
            const container = document.getElementById('system-stats-container');
            container.innerHTML = ''; // Clear previous stats

            const tempDiv = document.createElement('div');
            tempDiv.className = 'system-stat';
            tempDiv.style.height = '100%';
            let tempHtml = '<h2>Temperatures</h2>';
            state.components.forEach(component => {
                tempHtml += `<div>${component.label}: ${component.temperature.toFixed(2)}°C</div>`;
            });
            tempDiv.innerHTML = tempHtml;

            container.appendChild(tempDiv);
        }
    </script>
</body>
</html>