<!DOCTYPE html>
<html>
<head>
    <title>Rust Chess AI</title>
    <link rel="stylesheet" href="main_style.css">
</head>
<body>
    <div class="main-container">
        <div id="status-bar">
            <div id="generation-status" class="status-gauge"></div>
            <div id="cpu-status" class="status-gauge"></div>
            <div id="mem-status" class="status-gauge"></div>
        </div>

        <div id="matches-container">
            <!-- Match panes will be dynamically inserted here -->
        </div>

        <div id="bottom-container">
            <div id="log-container" style="flex: 2;">
                <h2>Log</h2>
                <div id="log-content" class="scroll-content"></div>
            </div>
            <div id="workers-container" style="flex: 1;">
                <h2>Worker Status</h2>
                <div id="workers-content" class="scroll-content"></div>
            </div>
            <div id="system-stats-container" style="flex: 1;">
                 <!-- System stats will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <div id="buttons">
        <a href="history.html" class="button-link">View History</a>
        <a href="sts.html" class="button-link">STS Dashboard</a>
        <button id="force_quit">Force Quit</button>
        <button id="reset_simulation">Reset Simulation</button>
    </div>

    <script>
        const PIECE_SYMBOLS = {
            'p': '♟', 'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚',
            'P': '♟', 'R': '♜', 'N': '♞', 'B': '♝', 'Q': '♛', 'K': '♚'
        };

        let ws;
        let gitHash = null;

        function connect() {
            console.log("Attempting to connect to WebSocket...");
            ws = new WebSocket(`${window.location.protocol === 'https:' ? 'wss:' : 'ws:'}//${window.location.host}/ws`);

            ws.onopen = () => {
                console.log("WebSocket connection established.");
                ws.send(JSON.stringify({ subscribe: "State" }));
                ws.send(JSON.stringify({ subscribe: "Log" }));
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);

                if (msg.type === 'State') {
                    const state = msg.payload;
                    if (gitHash === null) {
                        gitHash = state.git_hash;
                    } else if (gitHash !== state.git_hash) {
                        console.log("Git hash changed, reloading page.");
                        window.location.reload();
                    }
                    updateUi(state);
                } else if (msg.type === 'Log') {
                    appendLog(msg.payload);
                }
            };

            ws.onclose = () => {
                console.log("WebSocket connection closed. Attempting to reconnect in 1 second...");
                // Attempt to reconnect after a delay
                setTimeout(connect, 1000);
            };

            ws.onerror = (err) => {
                console.error("WebSocket error:", err);
                ws.close();
            };

            document.getElementById('force_quit').onclick = () => ws.send('force_quit');
            document.getElementById('reset_simulation').onclick = () => {
                if (confirm('Are you sure you want to reset the simulation? This will delete all progress.')) {
                    ws.send('reset_simulation');
                }
            };
        }

        connect();

        function updateStatusBar(state) {
            // Generation Status
            const genDiv = document.getElementById('generation-status');
            if (state.graceful_shutdown) {
                genDiv.innerHTML = 'Graceful shutdown initiated. Waiting for matches to complete...';
            } else {
                const progress = state.evolution_total_matches > 0 ? (state.evolution_matches_completed / state.evolution_total_matches) : 0;
                const round_text = state.evolution_total_rounds > 0 ? `R: ${state.evolution_current_round}/${state.evolution_total_rounds}` : '';
                genDiv.innerHTML = `
                    <div>G: ${state.evolution_current_generation} | ${round_text} | M: ${state.evolution_matches_completed}/${state.evolution_total_matches}</div>
                    <progress value="${progress}" max="1"></progress>
                `;
            }

            // CPU Status
            const cpuDiv = document.getElementById('cpu-status');
            cpuDiv.innerHTML = `
                <div>CPU Usage</div>
                <progress value="${state.cpu_usage}" max="100"></progress>
                <span>${state.cpu_usage.toFixed(2)}%</span>
            `;

            // Memory Status
            const memDiv = document.getElementById('mem-status');
            const memUsedGb = state.memory_usage / (1024 * 1024 * 1024);
            const memTotalGb = state.total_memory / (1024 * 1024 * 1024);
            memDiv.innerHTML = `
                <div>Memory Usage</div>
                <progress value="${state.memory_usage}" max="${state.total_memory}"></progress>
                <span>${memUsedGb.toFixed(2)} / ${memTotalGb.toFixed(2)} GB</span>
            `;
        }

        function updateMatches(matches) {
            const container = document.getElementById('matches-container');
            container.innerHTML = ''; // Clear existing matches

            const sortedMatches = Object.entries(matches).sort(([idA], [idB]) => idA - idB);

            if (sortedMatches.length === 0) {
                container.innerHTML = '<div style="text-align: center; width: 100%;">Waiting for matches to start...</div>';
                return;
            }

            for (const [id, match] of sortedMatches) {
                const pane = document.createElement('div');
                pane.className = 'match-pane';

                const header = document.createElement('div');
                header.className = 'match-header';
                const white_name = match.white_player.split('.')[0];
                const black_name = match.black_player.split('.')[0];
                const white_num = white_name.split('_').pop();
                const black_num = black_name.split('_').pop();
                header.textContent = `M${id}: ${white_num} v ${black_num}`;

                const boardContainer = document.createElement('div');
                boardContainer.className = 'board-container';
                boardContainer.innerHTML = renderBoard(match.board);

                const sanContainer = document.createElement('div');
                sanContainer.className = 'san-container';
                sanContainer.innerHTML = `<strong>Eval:</strong> ${match.eval} | <strong>Material:</strong> ${match.material}<br>${match.san}`;

                pane.appendChild(header);
                pane.appendChild(boardContainer);
                pane.appendChild(sanContainer);
                container.appendChild(pane);
            }
        }

        function renderBoard(fen) {
            const [boardState] = fen.split(' ');
            const rows = boardState.split('/');
            let html = '<div class="board">';

            for (let i = 0; i < 8; i++) {
                const row = rows[i];
                for (let j = 0; j < 8; j++) {
                    const isDark = (i + j) % 2 !== 0;
                    html += `<div class="square ${isDark ? 'dark' : 'light'}">`;

                    const piece = getPieceAt(row, j);
                    if (piece) {
                        const colorClass = piece === piece.toUpperCase() ? 'white-piece' : 'black-piece';
                        html += `<span class="piece ${colorClass}">${PIECE_SYMBOLS[piece]}</span>`;
                    } else {
                        html += '&nbsp;';
                    }
                    html += '</div>';
                }
            }
            html += '</div>';
            return html;
        }

        // This is a helper because FEN is tricky with the numbers for empty squares
        function getPieceAt(fenRow, fileIndex) {
            let currentFile = 0;
            for (const char of fenRow) {
                if (isNaN(parseInt(char))) { // It's a piece
                    if (currentFile === fileIndex) {
                        return char;
                    }
                    currentFile++;
                } else { // It's a number for empty squares
                    const emptySquares = parseInt(char);
                    if (fileIndex >= currentFile && fileIndex < currentFile + emptySquares) {
                        return null;
                    }
                    currentFile += emptySquares;
                }
            }
            return null; // Should not be reached in a valid FEN
        }


        function updateStsLeaderboard(leaderboard, generationId) {
            const container = document.getElementById('matches-container');
            container.innerHTML = ''; // Clear existing content

            if (!leaderboard || leaderboard.length === 0) {
                container.innerHTML = '<div style="text-align: center; width: 100%;">Waiting for STS results...</div>';
                return;
            }

            // Sort by ELO descending, with nulls last
            leaderboard.sort((a, b) => {
                if (a.elo === null) return 1;
                if (b.elo === null) return -1;
                return b.elo - a.elo;
            });

            const table = document.createElement('table');
            table.className = 'data-table';
            table.innerHTML = `
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Individual ID</th>
                        <th>STS ELO</th>
                        <th>Progress</th>
                    </tr>
                </thead>
                <tbody>
                </tbody>
            `;
            const tbody = table.querySelector('tbody');

            leaderboard.forEach((entry, index) => {
                const row = document.createElement('tr');
                const elo = entry.elo !== null ? entry.elo.toFixed(2) : 'N/A';
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td><a href="/individual.html?gen=${generationId}&ind=${entry.individual_id}">Individual ${entry.individual_id}</a></td>
                    <td>${elo}</td>
                    <td><progress value="${entry.progress}" max="1"></progress></td>
                `;
                tbody.appendChild(row);
            });

            container.appendChild(table);
        }

        function updateUi(state) {
            updateStatusBar(state);
            updateSystemStats(state);
            if (state.selection_algorithm === 'StsScore') {
                document.getElementById('matches-container').classList.add('sts-leaderboard-view');
                updateStsLeaderboard(state.sts_leaderboard, state.evolution_current_generation);
            } else {
                document.getElementById('matches-container').classList.remove('sts-leaderboard-view');
                updateMatches(state.active_matches);
            }
            updateWorkers(state.worker_statuses);
        }

        function appendLog(message) {
            const container = document.getElementById('log-content');
            const atBottom = container.scrollHeight - container.clientHeight <= container.scrollTop + 1;

            const line = document.createElement('div');
            line.innerHTML = message;
            container.appendChild(line);

            // Keep the log to a max of 100 entries
            while (container.children.length > 100) {
                container.removeChild(container.firstChild);
            }

            if (atBottom) {
                container.scrollTop = container.scrollHeight;
            }
        }

        function updateWorkers(statuses) {
            const container = document.getElementById('workers-content');
            if (!statuses || statuses.length === 0) {
                container.innerHTML = 'Initializing workers...';
                return;
            }
            container.innerHTML = statuses
                .sort((a, b) => a.id - b.id)
                .map(s => {
                    let statusText;
                    if (s.status.Busy) {
                        // Extract the job type from the debug string for cleaner display
                        const jobType = s.status.Busy.split(' ')[0].replace('{', '');
                        statusText = `<span style="color: #ff8c00;">Busy: ${jobType}</span>`;
                    } else {
                        statusText = '<span style="color: #00ff00;">Idle</span>';
                    }
                    return `<div>Worker ${s.id}: ${statusText}</div>`;
                })
                .join('');
        }

        function updateSystemStats(state) {
            const container = document.getElementById('system-stats-container');
            container.innerHTML = ''; // Clear previous stats

            const tempDiv = document.createElement('div');
            tempDiv.className = 'system-stat';
            tempDiv.style.height = '100%';
            let tempHtml = '<h2>Temperatures</h2>';
            state.components.forEach(component => {
                tempHtml += `<div>${component.label}: ${component.temperature.toFixed(2)}°C</div>`;
            });
            tempDiv.innerHTML = tempHtml;

            container.appendChild(tempDiv);
        }
    </script>
</body>
</html>